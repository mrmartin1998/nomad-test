Multiple Form Submissions Fix Guide
Problem
Forms were being submitted multiple times due to authentication redirects and state changes when the user returned from login.

Solution 1: Using useRef to Track Submission State

// Before:
// The form would resubmit whenever session/status changed (multiple times)

// After:
const hasAutoSubmitted = useRef(false);
  
useEffect(() => {
  const pendingSubmission = localStorage.getItem('form_pending_submission');
  
  if (pendingSubmission && !hasAutoSubmitted.current) {
    // Only process if we haven't already auto-submitted
    try {
      // Parse data, check timestamp
      const { formData, timestamp } = JSON.parse(pendingSubmission);
      
      // Auto-submit only once when authenticated
      if (session && status === 'authenticated') {
        hasAutoSubmitted.current = true; // Set flag to prevent resubmission
        localStorage.removeItem('form_pending_submission'); // Clear before submission
        handleSubmit(formData);
      }
    } catch (error) {
      console.error('Error parsing pending submission:', error);
    }
  }
}, [session, status]);

Why This Works
useRef vs useState:



useRef creates a mutable value that persists across re-renders
Unlike state variables, changing a ref doesn't trigger a re-render
Perfect for tracking "has this happened already?" flags
Single-time Action:

The useEffect still runs multiple times as auth state changes
But the submission only happens once thanks to the ref check
Solution 2: Immediate localStorage Cleanup

// Before:
if (session && status === 'authenticated') {
  handleSubmit(formData);
  // localStorage was cleared after response (too late)
}

// After:
if (session && status === 'authenticated') {
  hasAutoSubmitted.current = true;
  localStorage.removeItem('form_pending_submission'); // Clear BEFORE submission
  handleSubmit(formData);
}

Why This Works
Race Condition Prevention:
Other useEffect runs might read localStorage before the operation completes
Clearing storage immediately blocks any other execution paths from seeing the data
Even if multiple concurrent effects run, only one will process the submission
Optional Server-Side Protection
Adding a server-side check provides an additional safeguard:

// Check for recent duplicate submission (within the last 5 seconds)
const recentSubmission = await FormModel.findOne({
  userId: session.user.id,
  fechaCreacion: { $gte: new Date(Date.now() - 5000) } // Last 5 seconds
});

if (recentSubmission) {
  // Return existing submission instead of creating a new one
  return NextResponse.json({
    success: true,
    message: "Application submitted successfully",
    applicationId: recentSubmission._id.toString(),
    data: recentSubmission,
    isDuplicate: true
  });
}

Implementation Guide for All Forms
For each form, add:

const hasAutoSubmitted = useRef(false); to track submission state
Check !hasAutoSubmitted.current before processing auto-submissions
Set hasAutoSubmitted.current = true when auto-submitting
Call localStorage.removeItem() BEFORE submission, not after
Consider adding similar duplicate detection in API routes
This pattern works for any form that involves authentication redirects, where multiple re-renders can occur as the auth state changes.